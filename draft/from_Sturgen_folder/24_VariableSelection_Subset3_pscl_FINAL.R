#
# 24_VariableSelection_Subset3_pscl_final.R
#
# This script is modified on the top of "10_PSCL_Analysis.R"
#
# Purpose: stepwise addition to select variable to be included in the model.
#
# Instead of using negation of pattern to find the subset without a match, a simplier way is to use the "invert" option of "grep".
# (approach 1): grep("[^Stk_120_cnt]",c(X.var.num,X.var.cat),value=TRUE,invert=TRUE) to find out those entries in c(X.var.num,X.var.cat) which is not "Stk_120_cnt".  Please note: this will be wrongly exclude "Stk_12_cnt" in c(X.var.num,X.var.cat)
# (approach 2): grep("Stk_120_cnt",c(X.var.num,X.var.cat),value=TRUE,invert=TRUE)
#
#
# purpose: keey variables for each subset (by checking the plots generated by "22_Prep_Subset_Data.R") and use pscl to model it.
#
# -------------------------------------------------------------------------------------------------
# June 8, 2013: This is to check the subset data created by "22_Prep_Subset_Data.R" mainly on checking the re-grouping of lithology and particle size categorical variables.
#
# June 7, 2013: Chris M provided the re-group rules for the lithology and part size categorical variables for each subset of the data.
#
# June 4, 2013
# Variables to be retained for the analysis vary in terms of subsets.
# We are going to do the following five subsets
# 1. Lower - Gillnet	  (GN14S, GN41S, GN18S, GN81S)  
# 2. Lower - Trotline	  (TLC1S, TLC2S)
# 3. Lower - active gears (OT16S and TNS and TN25S)
# 4. Upper - active gears (OT16S and TNS and TN25S)
# 5. Upper - Trotline	  (TLC1S, TLC2S)
# -------------------------------------------------------------------------------------------------
# Chris Vernon prepared a revised data sheet on May 31,   2013 after having deleted some segment 7 data.
# Chris Vernon prepared a revised data sheet on May 27,   2013 with (1) relative discharge    and (2) new field names
#
# Data difference between May 27, 2013 and May 14, 2013

# The data has been pre-processed in excel in the following way before saved as the csv format to be used by this script.
# (1) replace all 1,380,446 NULL  with empty field
# (2) replace all       142 NaN   with empty field
# (3) replace all         0 -9999 with empty field
# (4) replace 8     "#DIV/0!"     with empty field in the CPUE field
# (5) replace 8 "DIV/0!" for "CPUE" and 1 "DIV/0!" for "CPUA" and the same number for "CPUE2" and "CPUA2".
#
# eliminate all stuff
rm(list = ls(all = TRUE))


# setup start date and time
start_time <- date();
Start.time <- Sys.time()
set.seed(12345, kind = NULL)	# set seed of random number

# close all devices which are currently open
device.list <- dev.list()
if (length(device.list) != 0){for (device.this in device.list){dev.off(device.this)}}


# today's month, day and year in the format of "Thu Jun 16 08:48:36 2011", 5 fields separated by space
today.month  <- strsplit(date(),"\\s+",perl=TRUE)[[1]][2]
today.day    <- strsplit(date(),"\\s+",perl=TRUE)[[1]][3]
today.year   <- strsplit(date(),"\\s+",perl=TRUE)[[1]][5]
today.hour   <- strsplit(strsplit(date(),"\\s+",perl=TRUE)[[1]][4],":",perl=TRUE)[[1]][1]
today.minute <- strsplit(strsplit(date(),"\\s+",perl=TRUE)[[1]][4],":",perl=TRUE)[[1]][2]
today.second <- strsplit(strsplit(date(),"\\s+",perl=TRUE)[[1]][4],":",perl=TRUE)[[1]][3]

#
# The same subset of data can be treated with either pscl, OpenBUGS, WinBUGS or JAGS.  So need to set up a method string
# ************************************************************************************************************************
method.string <- "pscl"

#
# -------------------------------------------------------------------------------------------------
# 	change to the script directory
# ------------------------------------------------------------------------------------------------- 
if(.Platform$OS.type == "unix") 
{
	Path.Current <- "C:/YuLong_Projects/FY2012_MORiver/DataAnalysis/0_scripts"
}else{
	Path.Current <- "C:/YuLong_Projects/FY2012_MORiver/DataAnalysis/0_scripts"
}
setwd(Path.Current)

FL.package  <- paste(Path.Current,"package_loading.R",sep="/")
source(FL.package)

# Data Folder
Path.IN  <- "C:/YuLong_Projects/FY2012_MORiver/DataAnalysis/22_Prep_Subset_Data"
Path.log <- "C:/YuLong_Projects/FY2012_MORiver/DataAnalysis/0_log"												
Path.OUT <- "C:/YuLong_Projects/FY2012_MORiver/DataAnalysis/24_VariableSelection_final"
if (!file.exists(Path.IN)) {stop(paste(" INPUT data folder does NOT exist!\n",sep=""))}
if (!file.exists(Path.log)){print(paste("NOT existing:",Path.log));dir.create(Path.log,showWarnings=TRUE,recursive=TRUE)}
if (!file.exists(Path.OUT)){print(paste("NOT existing:",Path.OUT));dir.create(Path.OUT,showWarnings=TRUE,recursive=TRUE)}

# data file
FL.OBJ.IN <- paste(Path.IN, "22_Prep_Subset_Data.RData", sep="/")
FL.LOG    <- paste(Path.log,"24_VariableSelection_Subset3_pscl_final.log",sep="/")	
if (!file.exists(FL.OBJ.IN)){stop(paste(" INPUT data file   does NOT exist!\n",sep=""))}
if  (file.exists(FL.LOG))   {print(paste(FL.LOG,      "exist.Delete it!")); file.remove(FL.LOG)}


FL.ReGroup.SUM <- paste(Path.OUT, paste("ReGrouping_Summary.csv",sep=""),sep="/")
if  (file.exists(FL.ReGroup.SUM)){print(paste(FL.ReGroup.SUM,"exist.Delete it!")); file.remove(FL.ReGroup.SUM)}


FL.RESL.OUT <- paste(Path.OUT,"24_VariableSelection_Subset3_pscl_finall.csv",sep="/")
if  (file.exists(FL.RESL.OUT)) {print(paste(FL.RESL.OUT,"exist.Delete it!")); file.remove(FL.RESL.OUT)}

# load the summary function
source("0_function.R")


# ******************************************************************
# Loop of Subsets
# ******************************************************************
subsets.section <- c("Upper","Upper","Lower","Lower","Lower","Upper",   "Lower",   "All")
subsets.gear    <- c("OT_TN","TLC",  "OT_TN","TLC",  "GN",   "Logistic","Logistic","All")
for (idx.subset in c(3))
{
	# -------------------------------------------------------------------------------------------------
	# 1. name subset and save them in the binary R data file
	# -------------------------------------------------------------------------------------------------
	subset.section <- subsets.section[idx.subset]
	subset.gear    <- subsets.gear[idx.subset]


	#
	# prepare INPUT DATA FILE
	#
	Path.IN.subset  <- paste(Path.IN, paste(paste("subset",idx.subset,sep=""),subset.section,subset.gear,sep="_"),sep="/")
	Path.OUT.subset <- paste(Path.OUT,paste(paste("subset",idx.subset,sep=""),subset.section,subset.gear,method.string,sep="_"),sep="/")
	if (!file.exists(Path.OUT.subset)){print(paste("NOT existing:",Path.OUT.subset));dir.create(Path.OUT.subset,showWarnings=TRUE,recursive=TRUE)}
	if (!file.exists(Path.IN.subset)) {print(paste("NOT existing:",Path.IN.subset," Check Why!\n",sep=""));die}
	
	#
	# load the data
	#
	load(FL.OBJ.IN)
	cat(paste("0. [",FL.OBJ.IN,"] has been loaded!\n",sep=""))
	cat(paste("0. [",FL.OBJ.IN,"] has been loaded!\n",sep=""),file=FL.LOG,append=TRUE)
	

	cat(paste("\n\n************************************ [",subset.gear,"] and [",subset.section,"] ","************************************","\n",sep=""))
	cat(paste("\n\n************************************ [",subset.gear,"] and [",subset.section,"] ","************************************","\n",sep=""),file=FL.LOG,append=TRUE)
	
	FL.OUT.Obj   <<- paste(Path.OUT.subset, paste("RData_Subset_",idx.subset,"_",subset.section,"_",subset.gear,"_",method.string,".RData",sep=""),sep="/")
	FL.OUT.Data  <<- paste(Path.OUT.subset, paste("Data_Subset_", idx.subset,"_",subset.section,"_",subset.gear,"_",method.string,".csv",  sep=""),sep="/")
	FL.OUT.Model <<- paste(Path.OUT.subset, paste("Model_Subset_",idx.subset,"_",subset.section,"_",subset.gear,"_",method.string,".csv",  sep=""),sep="/")
	if  (file.exists(FL.OUT.Obj))  {print(paste(FL.OUT.Obj,  "exist.Delete it!"));file.remove(FL.OUT.Obj)}
	if  (file.exists(FL.OUT.Data)) {print(paste(FL.OUT.Data, "exist.Delete it!"));file.remove(FL.OUT.Data)}
	# if  (file.exists(FL.OUT.Model)){print(paste(FL.OUT.Model,"exist.Delete it!"));file.remove(FL.OUT.Model)}


	# subset 1: upper OT and TN (active gear) [myData.Upper_Active]
	if (idx.subset == 1)
	{		
		myData.Sub      <- myData.Upper_Active    
		col.title.4.sub <- col.title.Upper_Active  
		col.class.4.sub <- col.class.Upper_Active  	

		Y.var  <- "Pal_cnt"
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUA.calc")
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc")											# DO NOT REMOVE THE TWO RELATIVE DISCHARGE VARIABLES
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","T_dist_up","T_dist_dn","Temp","Stk_12_cnt","Stk_36_cnt")				# removed variable for 1-variable combinations due to singularity: The variables experienced problems in model generations are listed in the end Such as "T_dist_up": "system is computationally singular: reciprocal condition number = 3.49394e-18"
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_up","D_dist_dn","Chan_wid","Wet_wid","T_dist_up","T_dist_dn","Clay_per")	# removed variable for 2-variable combinations due to singularity: 							
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","Sand_per")									# removed variable for 3-variable combinations due to singularity: 							
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","Sand_per","D_dist_near","T_dist_up","T_dist_dn","Stk_24_cnt","Stk_120_cnt")	# removed variable for 4-variable combinations due to singularity: 							
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_near","Braid","T_dist_dn","Clay_per","Rel_dsch_AY")			# removed variable for 5-variable combinations due to singularity: 															
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_dn","D_dist_near","Braid","Stk_24_cnt","new_part")      	# removed variable for 6-variable combinations due to singularity: 															
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_near","Grade_10_RM","Comp_per","Stk_12_cnt","Stk_36_cnt","Season","Seg","new_lith","new_part")			  	# removed variable for 7-variable combinations due to singularity: 															L
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","Grade_10_RM")	# removed variable for 8-varable combinations due to singularity: 															    	
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","GIS_RM","D_dist_up","D_dist_dn","D_dist_near","Grade_10_RM","Temp","Stk_36_cnt","Rel_dsch_WY","Seg","Rel_dsch_AY")  # removed variable for 9 varable combinations due to singularity: 	
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","GIS_RM","D_dist_up","D_dist_dn","D_dist_near","T_dist_near","Clay_per","Temp","Rel_dsch_WY","Season","new_part")	  # removed variable for 10 varable combinations due to singularity:
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_up","D_dist_dn","T_dist_near","Clay_per","Stk_12_cnt","Stk_60_cnt","Rel_dsch_WY","Season","new_lith")	# removed variable for 11 varable combinations due to singularity:
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_up","D_dist_dn","Chan_wid","Braid","Comp_per","Clay_per","VF_wid","Stk_24_cnt","Stk_36_cnt","new_lith")          # removed variable for 12 varable combinations due to singul                                                                                        	
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_up","D_dist_dn","D_dist_near","Clay_per","VF_wid","Temp","Depth_Mean","Stk_12_cnt","Stk_24_cnt","Stk_36_cnt","Stk_60_cnt","new_lith","new_part")				   # removed variable for 13 varable combinations due to singul  
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_up","D_dist_dn","D_dist_near","Temp","Depth_Mean","Clay_per","Stk_12_cnt","Stk_60_cnt","new_lith")		# Remove variable for 14 variables
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","D_dist_up","D_dist_dn","D_dist_near","Temp","Depth_Mean","Clay_per","Stk_12_cnt","Stk_60_cnt","new_lith","Braid","Comp_per","Stk_36_cnt","Season","new_part")	# Remove variable for 15 variables
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc")
	# subset 2: upper TLC [myData.Upper_TLC]
	}else if(idx.subset == 2){
		myData.Sub      <- myData.Upper_TLC    
		col.title.4.sub <- col.title.Upper_TLC  
		col.class.4.sub <- col.class.Upper_TLC 	
		
		Y.var  <- "Pal_cnt"
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUE.calc")
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                                                      "gear.type1","gear.type2","CPUE.calc","D_dist_up","D_dist_dn")	# "D_dist_up", "D_dist_dn" are completed correlated with "GIS_RM"
		
		
	# subset 3: lower OT & TN	[myData.Lower_Active]
	}else if(idx.subset == 3){
		myData.Sub      <- myData.Lower_Active    
		col.title.4.sub <- col.title.Lower_Active  
		col.class.4.sub <- col.class.Lower_Active 	
		
		Y.var  <- "Pal_cnt"
		var.rm.fix <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc")		
		var.rm     <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","GIS_RM","D_dist_up","Chan_wid","Wet_wid","Braid","T_dist_up","T_dist_dn","T_dist_near","Grade_10_RM","Comp_per","Sand_per","Clay_per","VF_wid","Temp","Depth_Mean","Stk_12_cnt","Stk_24_cnt","Stk_36_cnt","Stk_60_cnt","Stk_120_cnt","Rel_dsch_AY","Rel_dsch_WY","SY","Season","Seg","MicroClass","macro.type","new_NFHAP","new_lith")	# 1 variable	
		var.rm     <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","GIS_RM","D_dist_up","Chan_wid","Wet_wid","Braid","T_dist_up","T_dist_dn","T_dist_near","Grade_10_RM","Comp_per","Sand_per","Clay_per","VF_wid","Temp","Depth_Mean","Stk_12_cnt","Stk_24_cnt","Stk_36_cnt","Stk_60_cnt","Stk_120_cnt","Rel_dsch_AY","Rel_dsch_WY","SY","Season","Seg","MicroClass","macro.type","new_NFHAP","new_lith")	# 2 variable   
		
	# subset 4: lower TLC [myData.Lower_TLC]
	}else if(idx.subset == 4){
		myData.Sub      <- myData.Lower_TLC    
		col.title.4.sub <- col.title.Lower_TLC   
		col.class.4.sub <- col.class.Lower_TLC  	
		
		Y.var  <- "Pal_cnt"
		var.rm <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUE.calc")
		var.rm <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUE.calc")
		var.rm <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUE.calc","D_dist_up")	# Since "GIS_RM" is completed correlated with "D_dist_up"
		
	# subset 5: lower GN [myData.Lower_GN]
	}else if(idx.subset == 5){
		myData.Sub      <- myData.Lower_GN    
		col.title.4.sub <- col.title.Lower_GN   
		col.class.4.sub <- col.class.Lower_GN 	
		
		Y.var  <- "Pal_cnt"
		var.rm <- c("Gear","Season","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUE.calc")
		
		
	# subset 6: Logistic Upper [myData.Upper_Logistic]
	}else if(idx.subset == 6){
		myData.Sub      <- myData.Upper_Logistic    
		col.title.4.sub <- col.title.Upper_Logistic   
		col.class.4.sub <- col.class.Upper_Logistic 
		
		Y.var  <- "binary"
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUE","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUA.calc","CPUE.calc")
		var.rm <- c("Gear","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","MicroClass","WaterVel","Fish_cnt","CPUE","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist",                            "gear.type1","gear.type2","CPUA.calc","CPUE.calc")
		
		
	# subset 7: Logistic Lower [myData.Lower_Logistic]
	}else if(idx.subset == 7){
		myData.Sub      <- myData.Lower_Logistic    
		col.title.4.sub <- col.title.Lower_Logistic   
		col.class.4.sub <- col.class.Lower_Logistic 	
		
		Y.var  <- "binary"
		var.rm <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUE","CPUA","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUA.calc","CPUE.calc")
		
		
	# subset 8: All
	}else if(idx.subset == 8){
		myData.Sub      <- myData.All    
		col.title.4.sub <- col.title.All   
		col.class.4.sub <- col.class.All 
		
		var.rm <- c("Gear","D_dist_dn","D_dist_near","MA","Lith_1","Lith_2","Lith_desc","NFHAP","Tax_part_sz","Turb","Meso","WaterVel","Fish_cnt","CPUE","Stk_12_dist","Stk_24_dist","Stk_36_dist","Stk_60_dist","Stk_120_dist","Rel_dsch_AY","Rel_dsch_WY","gear.type1","gear.type2","CPUE.calc")
		
	}	
	
	
	# -----------------------------------------------------------------------------------------
	# July 10, 2013
	# remove NA rows before stepwise to ensure all variables starting with the same data
	# based on the initial assessment of the variables to be kept (not the actual variables we could be able to keep which depends on the computational singurity)
	# July 10, 2013
	# -----------------------------------------------------------------------------------------
	# naCol.2.rm: the number of missing of each variable
	# naRow.2.rm: the number of missing of each observation.  
	idxCol.2.subset <- match(var.rm.fix,names(myData.Sub))	
	naCol.2.rm <- apply(myData.Sub[,-idxCol.2.subset],2,function(x){sum(is.na(x))})
	naRow.2.rm <- apply(myData.Sub[,-idxCol.2.subset],1,function(x){sum(is.na(x))})
	if (sum(naCol.2.rm) != sum(naRow.2.rm)){cat("Something is not right!\n");die}
	idx.NA <- seq(1,dim(myData.Sub)[1])[naRow.2.rm>0]
	if(length(idx.NA)>0)
	{
		myData.Sub <- myData.Sub[-idx.NA,]
	}
	
	#
	# reduced data set for each subset of data
	idxCol.2.rm <- match(var.rm,names(myData.Sub))
	if(is.na(any(idxCol.2.rm))){cat(paste("Check the col names of [myDataSub] for Subset_",subset.section,"_",subset.gear,sep=""));die}
	myData.Reduced <- myData.Sub[,-idxCol.2.rm]

	
	 
	idx.2.rm <- match(var.rm,col.title.4.sub)
	if(is.na(any(idx.2.rm))){cat(paste("Check the col names of [col.title.4.sub] for Subset_",subset.section,"_",subset.gear,sep=""));die}	
	col.title.reduced <- col.title.4.sub[-idx.2.rm]
	col.class.reduced <- col.class.4.sub[-idx.2.rm]
		
	#	
	X.var.cat    <- grep("binary",col.title.reduced[col.class.reduced == "factor"],value=TRUE,invert=TRUE)
	X.var.num    <- grep("Pal_cnt",grep("SUPPORT.calc",col.title.reduced[col.class.reduced != "factor"],value=TRUE,invert=TRUE),value=TRUE,invert=TRUE)	
	X.var.offset <- "SUPPORT.calc"
	
	
	#
	myData.X.num    <- myData.Reduced[,X.var.num,   drop=FALSE]
	myData.X.cat    <- myData.Reduced[,X.var.cat,   drop=FALSE] 
	myData.X.offset <- myData.Reduced[,X.var.offset,drop=FALSE]
	myData.Y        <- myData.Reduced[,Y.var,       drop=FALSE] 
	
	
	
	# make sure the categorical are factors
	for (i in names(myData.X.cat))
	{
		if (!(is.factor(myData.X.cat[,i])))
		{
			myData.X.cat[,i] <- as.factor(myData.X.cat[,i])
		}
	}

	
	
	# standardized the numerical variables
	if (length(X.var.num)>0)
	{
		var.mean <- as.data.frame(matrix(rep(apply(myData.X.num,2,mean,na.rm=TRUE),dim(myData.X.num)[1]),nrow=dim(myData.X.num)[1],byrow=TRUE))
		var.sd   <- as.data.frame(matrix(rep(apply(myData.X.num,2,sd,na.rm=TRUE),  dim(myData.X.num)[1]),nrow=dim(myData.X.num)[1],byrow=TRUE))
		myData.X.num.std <- (myData.X.num - var.mean)/var.sd
	}else{
		myData.X.num.std <- myData.X.num
	}
	



	if(idx.subset == 3)	# PSCL Upper TLC
	{
		# [Subset 1 Upper OT & TN]: define an empty array to hold model summary
		model.count <- 0
		summary.out <- c()
		
		# compile a working data set
		if (dim(myData.X.num.std)[1]>0)
		{
			myData.Work <- cbind(myData.Y,myData.X.num.std,myData.X.cat,myData.X.offset)
		} else if (dim(myData.X.num.std)[1]<=0)
		{
			myData.Work <- cbind(myData.Y,myData.X.cat,myData.X.offset     )
		}
		

		# remove rows with NA
		naRow.2.rm <- apply(myData.Work,1,function(x){sum(is.na(x))})
		idx.NA <- seq(1,dim(myData.Work)[1])[naRow.2.rm>0]
		if(length(idx.NA)>0)
		{
			myData.Work <- myData.Work[-idx.NA,]
		}

		idx.lines <- dim(myData.Work)[1] + 2
		SUPPORT.calc <- myData.Work[,"SUPPORT.calc"]
		
		 cat(paste("We are there\n"))
		
		# # ---------------------------------------------------------------------------------
		# # [Subset 3 Upper OT & TN]: 1. model with 1 variable 
		# # ---------------------------------------------------------------------------------
		# save.command <- ""
		# no.tmp  <- length(c(X.var.num,X.var.cat))
		# idx.tmp <- 0
		# for (X.var.rm in c(X.var.num,X.var.cat))
		# {
		# 	idx.tmp <- idx.tmp + 1
		# 	idx.var.rm <- match(X.var.rm,names(myData.Work))				# the index of the variable to be removed in the data frame
		# 	if(!(is.na(idx.var.rm)))
		# 	{
		# 		model.count  <- model.count + 1
		# 		myData.Tmp   <- myData.Work[,c("Pal_cnt",X.var.rm)]
		# 		# model.Tmp    <- glm(binary ~ .,data=myData.Tmp,family=binomial("logit"))
		# 		
		# 
		# 		# -----------------------------------------------------------------------------------------------------------------
		# 		rm(df.coef.count,df.coef.zero,df.sum)
		# 		model.Tmp <- zeroinfl(Pal_cnt ~ ., data = myData.Tmp, dist = "poisson",offset=SUPPORT.calc)
		# 		# -----------------------------------------------------------------------------------------------------------------
		# 		
		# 		
		# 		model.ID     <- X.var.rm
		# 		model.string <- paste("Model",model.count," with ",X.var.rm,"\n",sep=" ")
		# 		model.no.var <- dim(myData.Tmp)[2] - 1
		# 		model.rm.var <- paste("all but",X.var.rm,sep=" ")
		#	 
		# 		model.formula       <- summary(model.Tmp)$call
		# 		model.coef.count    <- as.data.frame(summary(model.Tmp)$coef$count)
		# 		model.coef.zero     <- as.data.frame(summary(model.Tmp)$coef$zero)
		# 		model.sum           <- c(model.Tmp$df.null,			# null.df        
		# 					 model.Tmp$df.residual,			# resi.df   
		# 					 model.Tmp$loglik,			# loglik
		# 					 AIC(model.Tmp))		 	# AIC     
		# 		model.data.fit      <- cbind(model.Tmp$data,fitted.value=model.Tmp$fitted.values,residual=model.Tmp$residual)		                         
		# 
		# 		summary.this <- model.output.pscl(model.ID,model.string,model.count,model.no.var,model.formula,model.coef.count,model.coef.zero,model.sum,model.data.fit,model.rm.var)
		# 
		# 		if (model.count == 1){summary.out <- summary.this}else{summary.out <- rbind(summary.out,summary.this)}
		# 		
		# 		# assign the model coefficienct to an object 
		# 		command.string <- paste(paste("MODEL.1.Count_",X.var.rm,sep="")," <- model.coef.count",sep="")
		# 		eval(parse(text=command.string))
		# 		
		# 		command.string <- paste(paste("MODEL.1.Zero_",X.var.rm,sep="")," <- model.coef.zero",sep="")
		# 		eval(parse(text=command.string))				
		# 				
		#	 
		# 		save.command <- paste(save.command,",",paste("MODEL.1.Count_",X.var.rm,sep=""),paste("MODEL.1.Zero_",X.var.rm,sep=""),sep="")					# for all other model than the last one
		# 	      # save.command <- paste(save.command,",",paste("MODEL.1_",X.var.rm,sep=""),",file=\"",FL.OUT.Obj,"\")",sep="")	# FOR THE LAST MODEL			      
		# 	}
		# }
		# cat(paste("1. model with all 1 variable\n",sep=""))
		# cat(paste("1. model with all 1 variable\n",sep=""),file=FL.LOG,append=TRUE)		
		




		# ---------------------------------------------------------------------------------
		# [Subset 3 Upper OT & TN]: 2. model with 2 variable 
		# ---------------------------------------------------------------------------------
		save.command <- ""
		no.tmp  <- length(c(X.var.num,X.var.cat))
		idx.tmp <- 0
		for (X.var.rm in grep("new_meso",c(X.var.num,X.var.cat),value=TRUE,invert=TRUE))
		{
			idx.tmp <- idx.tmp + 1
			idx.var.rm <- match(X.var.rm,names(myData.Work))				# the index of the variable to be removed in the data frame
			if(!(is.na(idx.var.rm)))
			{
				model.count  <- model.count + 1
				myData.Tmp   <- myData.Work[,c("Pal_cnt","new_meso",X.var.rm)]
				# model.Tmp    <- glm(binary ~ .,data=myData.Tmp,family=binomial("logit"))
				
		
				# -----------------------------------------------------------------------------------------------------------------
				rm(df.coef.count,df.coef.zero,df.sum)
				model.Tmp <- zeroinfl(Pal_cnt ~ ., data = myData.Tmp, dist = "poisson",offset=SUPPORT.calc)
				# -----------------------------------------------------------------------------------------------------------------
				
				
				model.ID     <- X.var.rm
				model.string <- paste("Model",model.count," with ",X.var.rm," & new_meso\n",sep=" ")
				model.no.var <- dim(myData.Tmp)[2] - 1
				model.rm.var <- paste("all but new_meso & ",X.var.rm,sep=" ")
		
				model.formula       <- summary(model.Tmp)$call
				model.coef.count    <- as.data.frame(summary(model.Tmp)$coef$count)
				model.coef.zero     <- as.data.frame(summary(model.Tmp)$coef$zero)
				model.sum           <- c(model.Tmp$df.null,			# null.df        
							 model.Tmp$df.residual,			# resi.df   
							 model.Tmp$loglik,			# loglik
							 AIC(model.Tmp))		 	# AIC     
				model.data.fit      <- cbind(model.Tmp$data,fitted.value=model.Tmp$fitted.values,residual=model.Tmp$residual)		                         
		
				summary.this <- model.output.pscl(model.ID,model.string,model.count,model.no.var,model.formula,model.coef.count,model.coef.zero,model.sum,model.data.fit,model.rm.var)
		
				if (model.count == 1){summary.out <- summary.this}else{summary.out <- rbind(summary.out,summary.this)}
				
				# assign the model coefficienct to an object 
				command.string <- paste(paste("MODEL.2.Count_",X.var.rm,sep="")," <- model.coef.count",sep="")
				eval(parse(text=command.string))
				
				command.string <- paste(paste("MODEL.2.Zero_",X.var.rm,sep="")," <- model.coef.zero",sep="")
				eval(parse(text=command.string))				
				
		
				save.command <- paste(save.command,",",paste("MODEL.2.Count_",X.var.rm,sep=""),paste("MODEL.2.Zero_",X.var.rm,sep=""),sep="")					# for all other model than the last one
			      # save.command <- paste(save.command,",",paste("MODEL.2_",X.var.rm,sep=""),",file=\"",FL.OUT.Obj,"\")",sep="")	# FOR THE LAST MODEL			      
			}
		}
		cat(paste("2. model with all 2 variable\n",sep=""))
		cat(paste("2. model with all 2 variable\n",sep=""),file=FL.LOG,append=TRUE)		




		# # ---------------------------------------------------------------------------------
		# # [Subset 3 Upper OT & TN]: 3. model with 3 variable 
		# # ---------------------------------------------------------------------------------
		# save.command <- ""
		# no.tmp  <- length(c(X.var.num,X.var.cat))
		# idx.tmp <- 0
		# for (X.var.rm in grep("new_part",grep("new_meso",c(X.var.num,X.var.cat),value=TRUE,invert=TRUE),value=TRUE,invert=TRUE))
		# {
		# 	idx.tmp <- idx.tmp + 1
		# 	idx.var.rm <- match(X.var.rm,names(myData.Work))				# the index of the variable to be removed in the data frame
		# 	if(!(is.na(idx.var.rm)))
		# 	{
		# 		model.count  <- model.count + 1
		# 		myData.Tmp   <- myData.Work[,c("Pal_cnt","new_meso","new_part",X.var.rm)]
		# 		# model.Tmp    <- glm(binary ~ .,data=myData.Tmp,family=binomial("logit"))
		# 		
		# 
		# 		# -----------------------------------------------------------------------------------------------------------------
		# 		rm(df.coef.count,df.coef.zero,df.sum)
		# 		model.Tmp <- zeroinfl(Pal_cnt ~ ., data = myData.Tmp, dist = "poisson",offset=SUPPORT.calc)
		# 		# -----------------------------------------------------------------------------------------------------------------
		# 		
		# 		
		# 		model.ID     <- X.var.rm
		# 		
		# 		model.string <- paste("Model",model.count," with ",X.var.rm," & new_meso\new_part\n",sep=" ")
		# 		model.no.var <- dim(myData.Tmp)[2] - 1
		#		model.rm.var <- paste("all but new_meso\new_part & ",X.var.rm,sep=" ")
		# 
		# 		model.formula       <- summary(model.Tmp)$call
		# 		model.coef.count    <- as.data.frame(summary(model.Tmp)$coef$count)
		# 		model.coef.zero     <- as.data.frame(summary(model.Tmp)$coef$zero)
		# 		model.sum           <- c(model.Tmp$df.null,			# null.df        
		# 					 model.Tmp$df.residual,			# resi.df   
		# 					 model.Tmp$loglik,			# loglik
		# 					 AIC(model.Tmp))		 	# AIC     
		# 		model.data.fit      <- cbind(model.Tmp$data,fitted.value=model.Tmp$fitted.values,residual=model.Tmp$residual)		                         
		# 
		# 		summary.this <- model.output.pscl(model.ID,model.string,model.count,model.no.var,model.formula,model.coef.count,model.coef.zero,model.sum,model.data.fit,model.rm.var)
		# 
		# 		if (model.count == 1){summary.out <- summary.this}else{summary.out <- rbind(summary.out,summary.this)}
		# 		
		# 		# assign the model coefficienct to an object 
		# 		command.string <- paste(paste("MODEL.2.Count_",X.var.rm,sep="")," <- model.coef.count",sep="")
		# 		eval(parse(text=command.string))
		# 		
		# 		command.string <- paste(paste("MODEL.2.Zero_",X.var.rm,sep="")," <- model.coef.zero",sep="")
		# 		eval(parse(text=command.string))				
		#		
		# 
		# 		save.command <- paste(save.command,",",paste("MODEL.2.Count_",X.var.rm,sep=""),paste("MODEL.2.Zero_",X.var.rm,sep=""),sep="")					# for all other model than the last one
		# 	      # save.command <- paste(save.command,",",paste("MODEL.2_",X.var.rm,sep=""),",file=\"",FL.OUT.Obj,"\")",sep="")	# FOR THE LAST MODEL			      
		# 	}
		# }
		# cat(paste("2. model with all 2 variable\n",sep=""))
		# cat(paste("2. model with all 2 variable\n",sep=""),file=FL.LOG,append=TRUE)		



		
		# ---------------------------------------------------------------------------------
		# last: save all coefficients of all models
		# ---------------------------------------------------------------------------------
		 # eval(parse(text=save.command))
		
		# write summary of all MODEL out to the summary file
		cat(paste("summary,",            sep=""),file=FL.OUT.Model,append=TRUE)
		write.table(data.frame(summary.out),file=FL.OUT.Model,row.names=TRUE,col.names=TRUE,sep=",",append=TRUE)
		
	}else if (idx.subset == 7)	# Logistic Regression for the Lower River Stream
	{
	}
}


# -------------------------------------------------------------------------------------------------
# time used for completing this script
# -------------------------------------------------------------------------------------------------
End.time  <- Sys.time()
Diff.time <- End.time - Start.time
Diff.time

cat(paste("\n24_VariableSelection_Subset3_pscl_final.R is finished successfully at ",End.time,"!\n",sep=" "))
cat(paste("\n24_VariableSelection_Subset3_pscl_final.R is finished successfully at ",End.time,"!\n",sep=" "),file=FL.LOG,append=TRUE)

cat(paste("\nProcessing time for [24_VariableSelection_Subset3_pscl_final.R] is ",as.numeric(Diff.time, units="mins")," minutes\n",sep=" "))
cat(paste("\nProcessing time for [24_VariableSelection_Subset3_pscl_final.R] is ",as.numeric(Diff.time, units="mins")," minutes\n",sep=" "),file=FL.LOG,append=TRUE)

#
# put run related information into the log file
#
cat(paste("This run was conducted in ",.Platform$OS.type,"\n",sep=""));
cat(paste("This run was conducted in ",.Platform$OS.type,"\n",sep=""),file=FL.LOG,append=TRUE);

# get the version of R used for this computation and the latest version released
current.Rversion <- R.Version()$version.string
tmp = readLines("http://cran.r-project.org/sources.html")
rls = tmp[grep("latest release", tmp) + 1L]			# the version number is in the next line of 'The latest release'
latest.Rversion  <- gsub("(.*R-|\\.tar\\.gz.*)", "", rls)	# "The latest release: R-2.13.0.tar.gz"
if (latest.Rversion != current.Rversion)
{
	cat(paste("\n\nyou may want to upgrade R from the version you are using [",current.Rversion,"] to the latest version of [",latest.Rversion,"]\n",sep=""));
	cat(paste("\n\nyou may want to upgrade R from the version you are using [",current.Rversion,"] to the latest version of [",latest.Rversion,"]\n",sep=""),file=FL.LOG,append=TRUE);
}else{
	cat(paste("\n\nThe R version you are using is the latest version released so far!\n",sep=""))
	cat(paste("\n\nThe R version you are using is the latest version released so far!\n",sep=""),file=FL.LOG,append=TRUE)
}

# get the version information of the attached libraries
cat(paste("\n\nThe information of the packages you used for this calculation:\n"))
cat(paste("\n\nThe information of the packages you used for this calculation:\n"),file=FL.LOG,append=TRUE)
tmp <- sessionInfo()
pkg.loaded <- tmp$otherPkgs
no.pkg.loaded <- length(pkg.loaded)
for (i in seq(1,no.pkg.loaded))
{
	cat(paste(pkg.loaded[[i]]$Package,":",pkg.loaded[[i]]$Version," ",pkg.loaded[[i]]$Date,"\n",sep=" "))
	cat(paste(pkg.loaded[[i]]$Package,":",pkg.loaded[[i]]$Version," ",pkg.loaded[[i]]$Date,"\n",sep=" "),file=FL.LOG,append=TRUE)
}






